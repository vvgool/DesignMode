迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴
露该对象的内部细节。

　　从定义可见，迭代器模式是为容器而生。很明显，对容器对象的访问必然涉及到遍历算法。你可以一股脑的将遍历方法塞到容器对象中去；
或者根本不去提供什么遍历算法，让使用容器的人自己去实现去吧。这两种情况好像都能够解决问题。

　　然而在前一种情况，容器承受了过多的功能，它不仅要负责自己“容器”内的元素维护（添加、删除等等），而且还要提供遍历自身的接口；
而且由于遍历状态保存的问题，不能对同一个容器对象同时进行多个遍历。第二种方式倒是省事，却又将容器的内部细节暴露无遗。

　　而迭代器模式的出现，很好的解决了上面两种情况的弊端。先来看下迭代器模式的真面目吧。

　　迭代器模式由以下角色组成：

　　1) 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。

　　2) 具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。

　　3) 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。

　　4) 具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。


效果及实现要点

       迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
       迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
       迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。

总结
    Iterator模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问
    集合内部的数据。


迭代器模式的作用：

        它支持以不同的方式遍历一个聚合对象 ： 复杂的聚合可用多种方式进行遍历。迭代器模式使得改变遍历算法变得很容易 : 仅需用一个不同的
        迭代器的实例代替原先的实例即可。你也可以自己定义迭代器的子类以支持新的遍历。
         迭代器简化了聚合的接口 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了。这样就简化了聚合的接口。
        在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态。因此你可以同时进行多个遍历。
        在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

迭代器模式的缺点
       由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了
       系统的复杂性。


适用情况


由上面的讲述，我们可以看出迭代器模式给容器的应用带来以下好处：

    　　支持以不同的方式遍历一个容器角色。根据实现方式的不同，效果上会有差别。
    　　简化了容器的接口。但是在java Collection中为了提高可扩展性，容器还是提供了遍历的接口。
    　　对同一个容器对象，可以同时进行多个遍历。因为遍历状态是保存在每一个迭代器对象中的。


　　由此也能得出迭代器模式的适用范围：

    　　访问一个容器对象的内容而无需暴露它的内部表示。
    　　支持对容器对象的多种遍历。
    　　为遍历不同的容器结构提供一个统一的接口（多态迭代）。