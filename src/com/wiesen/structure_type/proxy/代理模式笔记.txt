模式的组成

    1)代理角色(Proxy):

    . 保存一个引用使得代理可以访问实体。若 RealSubject和Subject的接口相同，Proxy会引用Subject。

    . 提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。

    . 控制对实体的存取，并可能负责创建和删除它。

    . 其他功能依赖于代理的类型：

    • Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。

    • Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问。

    • Protection Proxy检查调用者是否具有实现一个请求所必需的访问权限。

    2) 抽象主题角色(Subject):定义真实主题角色RealSubject
     和 抽象主题角色Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使

    用Proxy。代理主题通过持有真实主题RealSubject的引用,不但可以控制真实主题RealSubject的创建或删除,可以在真实主题RealSubject被调用前进行拦截,或在调用后进行某些操作.

    3) 真实主题角色(RealSubject):定义了代理角色(proxy)所代表的具体对象



/************************************************************************************************************/

  代理模式: 为其他对象提供一种代理，并以控制对这个对象的访问。（Provide asurrogate or placeholder foranother

object tocontrol access to it. ）而对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。

它是给某一个对象提供一个替代者(占位者),使之在client对象和subject对象之间编码更有效率。代理可以提供延迟实例化(lazy instantiation)

,控制访问, 等等，包括只在调用中传递。 一个处理纯本地资源的代理有时被称作虚拟代理。远程服务的代理常常称为远程代理。

强制 控制访问的代理称为保护代理。


  在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy模式。下面是一些可以使用Proxy模式常见情况：

  1) 远程代理（Remote  Proxy）为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，
  也可是在另一台主机中，远程代理又叫做大使(Ambassador)

  2) 虚拟代理（Virtual Proxy）根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，
  真实对象只在需要时才会被真正创建。

  3) 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。

  4) 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。

  5) Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，
  对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。


/*****************************************************************************************************************/
 效果

    Proxy模式在访问对象时引入了一定程度的间接性。根据代理的类型，附加的间接性有多种用途：
    1) Remote Proxy可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，
    可以快速响应并处理客户端请求。

    2) Virtual Proxy 可以进行最优化，例如根据要求创建对象。即通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗。

    3) Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理（Housekeeping task） 。

    Proxy模式还可以对用户隐藏另一种称之为写时复制（copy-on-write）的优化方式，该优化与根据需要创建对象有关。拷贝一个庞大而复杂的对象
    是一种开销很大的操作，如果这个拷贝根本没有被修改，那么这些开销就没有必要。用代理延迟这一拷贝过程，我们可以保证只有当这个对象被修改
    的时候才对它进行拷贝。在实现copy-on-write时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当用户请求一个修改该实体的操作时，
    代理才会真正的拷贝它。在这种情况下，代理还必须减
    少实体的引用计数。当引用的数目为零时，这个实体将被删除。copy-on-write可以大幅度的降低拷贝庞大实体时的开销。

    代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

    代理模式的缺点
    由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
    实现代理模式需要额外的工作，有些代理模式的实现非常复杂。