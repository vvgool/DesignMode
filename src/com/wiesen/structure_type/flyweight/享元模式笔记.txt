一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。比如说一个文本系统，每个字母定一个对象，
那么大小写字母一共就是52个，那么就要定义52个对象。如果有一个1M的文本，那么字母是何其的多，如果每个字母都定义一个对象那么内存
早就爆了。那么如果要是每个字母都共享一个对象，那么就大大节约了资源。
　　
在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。Flyweight的内部状态是用来
共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。Flyweight模式是一个提高程序效率
和性能的模式,会大大加快程序的运行速度.应用场合很多

/**************************************************************************************/


定义与分类

享元模式英文称为“Flyweight Pattern”，我非常感谢将Flyweight Pattern翻译成享元模式的那位强人，因为这个词将这个模式使用的
方式明白得表示了出来；如果翻译成为羽量级模式或者蝇量级模式等等，虽然可以含蓄的表现出使用此模式达到的目的，但是还是没有抓住此
模式的关键。

享元模式的定义为：采用一个共享来避免大量拥有相同内容对象的开销。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式
高效的支持大量的细粒度对象。

在名字和定义中都体现出了共享这一个核心概念，那么怎么来实现共享呢？要知道每个事物都是不同的，但是又有一定的共性，如果只有完全
相同的事物才能共享，那么享元模式可以说就是不可行的；因此我们应该尽量将事物的共性共享，而又保留它的个性。为了做到这点，享元模
式中区分了内蕴状态和外蕴状态。内蕴状态就是共性，外蕴状态就是个性了。

注：共享的对象必须是不可变的，不然一变则全变（如果有这种需求除外）。

   内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴
   状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象
   出来。至于怎样来维护客户端保持的外蕴状态和享元内部保持的内蕴状态的对应关系，你先不用担心这个问题，我们后面会涉及到的。

/****************************************************************************************************/

结构

先从简单的入手，看看单纯享元模式的结构。

1)抽象享元角色：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。在Java中可以由抽象类、接口来担当。

2)具体享元角色：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。

3)享元工厂角色：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！

4)客户端角色：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。


复合享元模式的结构。

1)抽象享元角色：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。在Java中可以由抽象类、接口来担当。

2)具体享元角色：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。

3)复合享元角色：它所代表的对象是不可以共享的，并且可以分解成为多个单纯享元对象的组合。

4)享元工厂角色：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！

5)客户端角色：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。

/**********************************************************************************/

使用优缺点

享元模式优点就在于它能够大幅度的降低内存中对象的数量；而为了做到这一步也带来了它的缺点：它使得系统逻辑复杂化，而且在一定程度上外蕴状态
影响了系统的速度。

所以一定要切记使用享元模式的条件：

1)系统中有大量的对象，他们使系统的效率降低。

2)这些对象的状态可以分离出所需要的内外两部分。

外蕴状态和内蕴状态的划分以及两者关系的对应也是非常值得重视的。只有将内外划分妥当才能使内蕴状态发挥它应有的作用；如果划分失误，
在最糟糕的情况下系统中的对象是一个也不会减少的！两者的对应关系的维护和查找也是要花费一定的空间（当然这个比起不使用共享对象要小得多）
和时间的，可以说享元模式就是使用时间来换取空间的。在Gof的书中是使用了B树来进行对应关系查找优化。